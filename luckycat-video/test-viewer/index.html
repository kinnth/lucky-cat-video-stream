<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuckyCat Video Processing Test</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>
        <h1>üé¨ LuckyCat Video Processing</h1>
        <div class="header-sub">Test Worker v1.0</div>
    </header>

    <div class="main-grid">
        <!-- ROW 1: Source & Control & Player -->

        <!-- Panel 1: Source Selection -->
        <div class="panel">
            <h2>1. Select Source (DailyMotion)</h2>
            <div class="video-list" id="testVideos">
                <div class="video-item" data-id="x9zbleo" onclick="selectVideo(this)">
                    <div>
                        <h3>hrs-5810</h3>
                        <span>ID: x9zbleo</span>
                    </div>
                </div>
                <div class="video-item" data-id="x9zbdjk" onclick="selectVideo(this)">
                    <div>
                        <h3>donat Topping</h3>
                        <span>ID: x9zbdjk</span>
                    </div>
                </div>
                <div class="video-item" data-id="x9zalt4" onclick="selectVideo(this)">
                    <div>
                        <h3>Cochinillo</h3>
                        <span>ID: x9zalt4</span>
                    </div>
                </div>
                <div class="video-item" data-id="x9zafgq" onclick="selectVideo(this)">
                    <div>
                        <h3>hrs-8748</h3>
                        <span>ID: x9zafgq</span>
                    </div>
                </div>
                <div class="video-item" data-id="x9zafcs" onclick="selectVideo(this)">
                    <div>
                        <h3>hrs-5888</h3>
                        <span>ID: x9zafcs</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Panel 2: Actions & Status -->
        <div class="panel">
            <h2>2. Control & Status</h2>
            <button id="loadBtn" class="action-btn primary" onclick="loadVideo()" disabled>üì• Load Video</button>
            <button id="uploadBtn" class="action-btn primary" onclick="uploadToStream()" disabled>üöÄ Upload to
                Cloudflare</button>

            <div class="meta-group">
                <div class="meta-row">
                    <span class="meta-label">Selected ID</span>
                    <span class="meta-val" id="selectedIdDisplay">-</span>
                </div>
                <div class="meta-row">
                    <span class="meta-label">Stream UID</span>
                    <span class="meta-val" id="streamUid">-</span>
                </div>
                <div class="meta-row">
                    <span class="meta-label">Status</span>
                    <span class="meta-val status-idle" id="status">Idle</span>
                </div>
            </div>

            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill">
                </div>
            </div>

            <div class="log-box" id="log"></div>
        </div>

        <!-- Panel 3: Video Player -->
        <div class="panel">
            <h2>3. Video Player</h2>
            <div class="video-wrapper">
                <video id="player" controls></video>
            </div>
            <!-- Hidden container for processed player injection -->
            <div id="processedVideoSection" class="processed-video-section"></div>

            <div class="meta-row mt-auto">
                <span class="meta-label">Duration</span>
                <span class="meta-val" id="videoDuration">-</span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Dimensions</span>
                <span class="meta-val" id="videoDimensions">-</span>
            </div>
        </div>

        <!-- ROW 2: Media Assets -->

        <!-- Panel 4: Keyframes -->
        <div class="panel">
            <h2>4. Keyframes (8)</h2>
            <div class="kf-grid" id="keyframes">
                <div class="kf-placeholder">
                    Frames appear after processing
                </div>
            </div>
        </div>

        <!-- Panel 5: VTT File Link -->
        <div class="panel">
            <h2>5. VTT Captions File</h2>
            <div id="vttLinkSection" style="padding: 10px;">
                <p style="color: #888; font-size: 0.85rem; margin-bottom: 10px;">
                    Cloudflare generates a VTT caption file for each video. The link will appear below once processing
                    is complete.
                </p>
                <div id="vttLinkContainer">
                    <span style="color: #555;">(Waiting for video processing...)</span>
                </div>
            </div>
        </div>

        <!-- Panel 6: CSV Input -->
        <div class="panel">
            <h2>6. CSV Captions (AI Input)</h2>
            <textarea id="csvContent" class="caption-text text-sage" readonly
                placeholder="CSV data sent to AI will appear here..."></textarea>
        </div>

        <!-- ROW 3: AI Analysis -->

        <!-- Panel 7: AI Control & Debug -->
        <div class="panel">
            <h2>7. AI Analysis</h2>
            <button id="analyzeBtn" class="action-btn success" onclick="analyzeWithAI()" disabled>ü§ñ Trigger
                Analysis</button>

            <div class="scroll-area-debug">
                <div class="debug-label mb-5">Debug Info</div>
                <div id="aiDebug" style="display: none;">
                    <div class="mb-5">
                        <strong class="debug-label">System Prompt</strong>
                        <div id="debugSystemPrompt" class="debug-box">
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong style="color: #555; font-size: 0.75rem;">User Prompt</strong>
                        <div id="debugUserPrompt" class="debug-box">
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong style="color: #555; font-size: 0.75rem;">Transcription</strong>
                        <div id="debugTranscription" class="debug-box">
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong style="color: #555; font-size: 0.75rem;">Screenshots Used</strong>
                        <div id="debugScreenshots" style="display:flex; gap:2px; height: 30px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Panel 8: AI Main Results -->
        <div class="panel">
            <h2>8. Main Results</h2>
            <div class="meta-group">
                <div class="meta-label">Title</div>
                <div id="aiTitle" class="result-title">-</div>
            </div>
            <div class="scroll-area-debug">
                <div class="meta-label">Description</div>
                <div id="aiDescription" class="result-desc">-</div>
            </div>
        </div>

        <!-- Panel 9: AI Metadata Stats -->
        <div class="panel">
            <h2>9. Metadata & Tags</h2>

            <div class="meta-row">
                <span class="meta-label">Category</span>
                <span class="meta-val" id="aiCategory">-</span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Rating</span>
                <span class="meta-val" id="aiRating">-</span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Mood / Lang</span>
                <span class="meta-val" id="aiMood">-</span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Confidence</span>
                <span class="meta-val" id="aiConfidence">-</span>
            </div>

            <div class="mt-15">
                <div class="meta-label mb-5">Tags</div>
                <div class="tag-cloud" id="aiTags">
                    <span class="header-sub">-</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        const WORKER_URL = 'https://lucky-cat-video-stream.kinnth.workers.dev';
        const LUCKYCAT_API = 'https://api-devel.luckycat.me';
        const ACCOUNT_ID = '90a991930af94aed0c6aee317e4eea59';

        // --- CONFIGURATION ---
        const CONFIG = {
            POLL_INTERVAL_MS: 2000,
            MAX_POLL_ATTEMPTS: 150,        // 5 minutes at 2s intervals
            RETRY_ATTEMPTS: 3,             // Retries for transient failures
            RETRY_DELAY_MS: 1000,          // Delay between retries
            CAPTION_TIMEOUT_POLLS: 60      // Max polls waiting for captions
        };

        // --- STATE ---
        let selectedDmId = null;
        let currentVideoData = null;
        let currentStreamUid = null;
        let statusPollInterval = null;
        let currentVideoDuration = null;

        // --- HELPERS ---

        /**
         * Fetch with automatic retry for transient errors
         */
        async function fetchWithRetry(url, options = {}, retries = CONFIG.RETRY_ATTEMPTS) {
            for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                    const response = await fetch(url, options);
                    // If server error (5xx) or timeout, we might want to retry
                    // For now, retry on any non-OK that isn't a 4xx (client error)
                    if (!response.ok && response.status >= 500 && attempt < retries) {
                        log(`   ‚ö†Ô∏è Request failed (attempt ${attempt}/${retries}): HTTP ${response.status}`, 'warn');
                        await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY_MS * attempt));
                        continue;
                    }
                    return response;
                } catch (e) {
                    if (attempt === retries) throw e;
                    log(`   ‚ö†Ô∏è Network error (attempt ${attempt}/${retries}): ${e.message}`, 'warn');
                    await new Promise(r => setTimeout(r, CONFIG.RETRY_DELAY_MS * attempt));
                }
            }
        }

        /**
         * Centralized status updater with visual feedback
         */
        function updateStatus(text, type = 'default') {
            const statusEl = document.getElementById('status');
            if (!statusEl) return;

            statusEl.textContent = text;
            statusEl.className = 'meta-val'; // Reset base class
            statusEl.style.color = ''; // Clear any inline style

            switch (type) {
                case 'processing':
                    statusEl.classList.add('status-processing');
                    break;
                case 'success':
                    statusEl.classList.add('status-success');
                    break;
                case 'error':
                    statusEl.classList.add('status-error');
                    break;
                default: // idle/default
                    statusEl.classList.add('status-idle');
            }
        }

        function log(msg, type = 'default') {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const typeClass = type !== 'default' ? ` ${type}` : '';
            logEl.innerHTML += `<div class="log-entry"><span class="log-time">[${time}]</span> <span class="log-msg${typeClass}">${msg}</span></div>`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        function setStep(stepNum) {
            return; // No-op
        }

        function setProgress(pct) {
            const bar = document.getElementById('progressBar');
            const fill = document.getElementById('progressFill');
            if (bar) bar.style.display = 'block';
            if (fill) fill.style.width = pct + '%';
        }

        function selectVideo(el) {
            console.log('Video clicked:', el.dataset.id);
            try {
                document.querySelectorAll('.video-item').forEach(c => c.classList.remove('selected'));
                el.classList.add('selected');
                selectedDmId = el.dataset.id;

                // Update display
                const displayEl = document.getElementById('selectedIdDisplay');
                if (displayEl) displayEl.textContent = selectedDmId;

                const btn = document.getElementById('loadBtn');
                if (btn) {
                    btn.disabled = false;
                    log(`‚úÖ Selected video: ${selectedDmId}`, 'success');
                }
            } catch (e) {
                console.error('Error in selectVideo:', e);
                log(`‚ùå Selection error: ${e.message}`, 'error');
            }
        }

        function resetDashboard() {
            // Stop any ongoing polling
            if (statusPollInterval) {
                clearInterval(statusPollInterval);
                statusPollInterval = null;
            }

            // Reset JS state
            currentVideoData = null;
            currentStreamUid = null;
            currentVideoDuration = null;

            // Reset UI
            document.getElementById('processedVideoSection').style.display = 'none';
            document.getElementById('processedVideoSection').innerHTML = ''; // Stop video playback

            const player = document.getElementById('player');
            player.style.display = 'block';
            player.src = ''; // Unload previous video

            // Buttons
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('analyzeBtn').disabled = true;

            // Status & Progress
            document.getElementById('status').textContent = 'Idle';
            document.getElementById('status').className = 'meta-val status-idle';
            document.getElementById('status').style.color = '';
            document.getElementById('streamUid').textContent = '-';
            document.getElementById('videoDuration').textContent = '-';
            document.getElementById('videoDimensions').textContent = '-';

            document.getElementById('progressBar').style.display = 'none';
            document.getElementById('progressFill').style.width = '0%';

            // Captions
            // Reset VTT link and CSV content
            document.getElementById('vttLinkContainer').innerHTML = '<span style="color: #555;">(Waiting for video processing...)</span>';
            document.getElementById('csvContent').value = '';

            // Keyframes
            document.getElementById('keyframes').innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #555; padding-top: 100px;">Frames appear after processing</div>';

            // AI Results
            document.getElementById('aiTitle').textContent = '-';
            document.getElementById('aiDescription').textContent = '-';
            document.getElementById('aiCategory').textContent = '-';
            document.getElementById('aiRating').textContent = '-';
            document.getElementById('aiMood').textContent = '-';
            document.getElementById('aiConfidence').textContent = '-';
            document.getElementById('aiTags').innerHTML = '<span style="color: #555; font-size: 0.8rem;">-</span>';

            // Debug
            document.getElementById('aiDebug').style.display = 'none';
            document.getElementById('debugSystemPrompt').textContent = '';
            document.getElementById('debugUserPrompt').textContent = '';
            document.getElementById('debugScreenshots').innerHTML = '';
        }

        async function loadVideo() {
            console.log('loadVideo initiated. ID:', selectedDmId);
            if (!selectedDmId) return;

            const btn = document.getElementById('loadBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            updateStatus('Loading metadata...', 'processing');

            try {
                // Reset state
                resetDashboard();

                // Step 1a: Get video metadata
                log(`üì• [STEP 1a] Fetching DailyMotion metadata...`, 'info');
                const dmResponse = await fetchWithRetry(`${WORKER_URL}/dm/${selectedDmId}`);

                if (dmResponse && dmResponse.ok) {
                    const dmData = await dmResponse.json();
                    currentVideoDuration = dmData.duration;
                    log(`   ‚Üí DM Title: "${dmData.title}"`, 'info');
                    document.getElementById('videoDuration').textContent = `${dmData.duration}s`;
                }

                // Step 1b: Get playback URLs
                log(`üì• [STEP 1b] Fetching playback URLs...`, 'info');
                const response = await fetchWithRetry(`${LUCKYCAT_API}/video/playback_source_by_dm_id/${selectedDmId}`);

                if (!response || !response.ok) throw new Error(`API returned ${response ? response.status : 'No Response'}`);

                const data = await response.json();
                currentVideoData = data;

                // Set video source
                const mp4Source = data.mp4?.find(m => m.quality === '720p') || data.mp4?.[0];
                const player = document.getElementById('player');

                // Show source player, hide processed
                player.style.display = 'block';
                document.getElementById('processedVideoSection').style.display = 'none';

                if (mp4Source) {
                    player.src = mp4Source.url;
                    log(`   ‚Üí Loaded ${mp4Source.quality} MP4`, 'success');

                    player.onloadedmetadata = function () {
                        const duration = player.duration;
                        currentVideoDuration = duration;
                        document.getElementById('videoDuration').textContent = `${duration.toFixed(1)}s`;

                        // Update dimensions if available
                        if (player.videoWidth) {
                            document.getElementById('videoDimensions').textContent = `${player.videoWidth}x${player.videoHeight}`;
                        }
                    };

                    document.getElementById('uploadBtn').disabled = false;
                    updateStatus('Loaded', 'success');
                    log(`‚úÖ [STEP 1 COMPLETE] Video loaded`, 'success');
                }
            } catch (error) {
                log(`‚ùå [STEP 1 FAILED] ${error.message}`, 'error');
                updateStatus('Load Failed - Retry', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'üì• Load Video';
            }
        }

        async function uploadToStream() {
            if (!currentVideoData) return;

            const btn = document.getElementById('uploadBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Uploading...';

            // Step 2 logic
            const mp4Source = currentVideoData.mp4?.find(m => m.quality === '720p') || currentVideoData.mp4?.[0];
            if (!mp4Source) {
                log('‚ùå No MP4 source available', 'error');
                btn.disabled = false;
                btn.textContent = 'üöÄ Upload to Cloudflare';
                updateStatus('Error: No MP4 Source', 'error');
                return;
            }

            log(`üì§ [STEP 2] Direct upload to Cloudflare Stream...`, 'info');
            updateStatus('Uploading...', 'processing');

            if (document.getElementById('progressBar')) {
                document.getElementById('progressBar').style.display = 'block';
                setProgress(5);
            }

            try {
                // Step 2a: Get direct upload URL
                const uploadUrlResponse = await fetchWithRetry(`${WORKER_URL}/upload/direct`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        maxDurationSeconds: Math.max(60, (currentVideoDuration || 60) * 2),
                        meta: {
                            dm_id: selectedDmId,
                            source: 'dailymotion',
                            quality: mp4Source.quality
                        }
                    })
                });

                if (!uploadUrlResponse || !uploadUrlResponse.ok) throw new Error('Failed to get upload URL');
                const uploadUrlData = await uploadUrlResponse.json();
                if (!uploadUrlData.success) throw new Error(uploadUrlData.error);

                const { uid, uploadURL } = uploadUrlData;
                currentStreamUid = uid;
                document.getElementById('streamUid').textContent = uid;
                setProgress(15);

                // Step 2b: Download video
                log(`   ‚Üí Downloading from DM...`, 'info');
                // Note: Not using fetchWithRetry for large binary download to avoid re-downloading huge files multiple times unnecessarily, 
                // but could add it if flaky. For now, keeping standard fetch for the blob.
                const videoResponse = await fetch(mp4Source.url);
                if (!videoResponse.ok) throw new Error(`Download failed: ${videoResponse.status}`);
                const videoBlob = await videoResponse.blob();
                setProgress(50);

                // Step 2c: Upload to Cloudflare
                log(`   ‚Üí Uploading to Stream...`, 'info');
                const formData = new FormData();
                formData.append('file', videoBlob, `${selectedDmId}.mp4`);

                const uploadResponse = await fetch(uploadURL, { method: 'POST', body: formData });
                if (!uploadResponse.ok) throw new Error(`Upload failed: ${uploadResponse.status}`);

                log(`‚úÖ [STEP 2 COMPLETE] Uploaded!`, 'success');
                updateStatus('Uploaded - Processing...', 'processing');
                setProgress(80);
                startStatusPolling(uid);

            } catch (error) {
                log(`‚ùå [STEP 2 FAILED] ${error.message}`, 'error');
                updateStatus('Upload Failed', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'üöÄ Upload to Cloudflare';
            }
        }

        function startStatusPolling(uid) {
            if (statusPollInterval) clearInterval(statusPollInterval);

            let pollCount = 0;
            let consecutiveErrors = 0;
            const MAX_CONSECUTIVE_ERRORS = 5;

            log(`üîÑ [STEP 3] Polling status for UID: ${uid}...`, 'info');
            updateStatus('Processing...', 'processing');

            statusPollInterval = setInterval(async () => {
                pollCount++;

                // Timeout check
                if (pollCount > CONFIG.MAX_POLL_ATTEMPTS) {
                    clearInterval(statusPollInterval);
                    statusPollInterval = null;
                    log(`‚è∞ [STEP 3 TIMEOUT] Polling timed out after ${pollCount} attempts`, 'error');
                    updateStatus('Timeout - Check Worker', 'error');
                    return;
                }

                try {
                    const res = await fetch(`${WORKER_URL}/status/${uid}`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);

                    const data = await res.json();
                    consecutiveErrors = 0; // Reset on success

                    // Update progress
                    const pct = parseFloat(data.pctComplete) || 0;
                    updateStatus(`Processing (${pct}%)`, 'processing');
                    setProgress(pct);

                    if (data.readyToStream) {
                        handleProcessingComplete(uid, data);
                    } else if (data.status === 'error' || data.error) {
                        // API returned error
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                        const errMsg = data.error?.message || data.error || 'Unknown processing error';
                        log(`‚ùå [STEP 3 FAILED] ${errMsg}`, 'error');
                        updateStatus(`Error: ${errMsg}`, 'error');
                    }
                    // else: still processing, continue polling

                } catch (e) {
                    consecutiveErrors++;
                    // Only log every few errors to avoid spamming the log
                    if (consecutiveErrors === 1 || consecutiveErrors % 3 === 0) {
                        log(`   ‚ö†Ô∏è Poll error (${consecutiveErrors}/${MAX_CONSECUTIVE_ERRORS}): ${e.message}`, 'warn');
                    }

                    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                        log(`‚ùå [STEP 3 FAILED] Too many consecutive errors`, 'error');
                        updateStatus('Connection Lost - Refresh', 'error');
                    }
                }
            }, CONFIG.POLL_INTERVAL_MS);
        }

        function handleProcessingComplete(uid, data) {
            // Stop polling
            if (statusPollInterval) clearInterval(statusPollInterval);
            statusPollInterval = null;

            log(`‚úÖ [STEP 3 COMPLETE] Video Ready!`, 'success');
            log(`   ‚Üí Duration: ${data.duration?.toFixed(1)}s, Dimensions: ${data.dimensions}`, 'success');

            setProgress(100);
            updateStatus('Ready', 'success');
            document.getElementById('status').className = 'status ready'; // Keep class for potential CSS hooks
            document.getElementById('videoDuration').textContent = `${data.duration?.toFixed(1)}s`;
            document.getElementById('videoDimensions').textContent = data.dimensions;

            // 1. Captions - Show VTT link and CSV content
            const captions = data.captions || [];
            const anyReadyCaption = captions.find(c => c.status === 'ready');

            // Use worker proxy endpoint for VTT access (direct Cloudflare URLs require API auth)
            const vttProxyUrl = `${WORKER_URL}/captions/${uid}`;
            const vttLinkContainer = document.getElementById('vttLinkContainer');

            if (anyReadyCaption) {
                log(`   ‚úÖ Captions detected: ${anyReadyCaption.label}`, 'success');

                // Fetch captions and validate availability
                fetchWithRetry(vttProxyUrl)
                    .then(r => r.json())
                    .then(d => {
                        if (d.vtt && d.vtt.length > 10) {
                            // VTT is available - show link and CSV
                            vttLinkContainer.innerHTML = `
                                <span style="color: #10b981; margin-bottom: 10px; display: block;">‚úÖ VTT Ready</span>
                                <a href="${vttProxyUrl}" target="_blank" class="link-cyan" style="display: inline-block; margin-bottom: 5px;">
                                    üìÑ View VTT via Worker API üîó
                                </a>
                                <br>
                                <span style="color: #666; font-size: 0.75rem;">
                                    Segments: ${d.vtt.split('-->').length - 1 || 'Unknown'}
                                </span>
                            `;

                            const csvBox = document.getElementById('csvContent');
                            if (csvBox) {
                                csvBox.value = d.csv || '(No text in captions - video may have no speech)';
                            }
                            log(`   üìÑ Captions loaded`, 'success');
                        } else {
                            // VTT exists but empty
                            vttLinkContainer.innerHTML = `
                                <span style="color: #f59e0b;">‚ö†Ô∏è VTT exists but contains no speech</span>
                            `;
                            document.getElementById('csvContent').value = '(Video has no detected speech)';
                        }
                    })
                    .catch(e => {
                        log(`   ‚ö†Ô∏è Failed to load captions: ${e.message}`, 'warn');
                        vttLinkContainer.innerHTML = `
                            <span style="color: #ef4444;">‚ùå Failed to load VTT</span>
                        `;
                    });
            } else {
                log(`   ‚ö†Ô∏è Captions not ready yet.`, 'warn');
                document.getElementById('csvContent').value = '(Captions still generating - check VTT link later)';

                // Trigger caption generation
                log(`   ‚Üí Triggering caption generation...`, 'info');
                fetch(`${WORKER_URL}/captions/generate/${uid}`, { method: 'POST' })
                    .then(r => r.json())
                    .then(d => {
                        if (d.success) log(`   ‚úÖ Caption generation started`, 'success');
                        else log(`   ‚ö†Ô∏è Caption generation trigger failed: ${d.error}`, 'warn');
                    })
                    .catch(e => log(`   ‚ö†Ô∏è Caption trigger error: ${e.message}`, 'warn'));

                // Poll for captions in background
                pollForCaptions(uid);

                // Auto-advance to AI analysis even if captions are missing
                setTimeout(() => analyzeWithAI(), 2000); // Give it a moment
            }

            // 2. Keyframes (Preview)
            // Display immediately using calculated timestamps
            generateStreamKeyframes(uid, data.duration);

            // 3. Processed Video Player
            // Validate and show processed video
            validateAndShowVideo(data, uid);

            // Enable Analysis
            document.getElementById('analyzeBtn').disabled = false;
            setStep(4);
            log(`ü§ñ [STEP 4] Ready for AI analysis.`, 'info');
        }

        async function analyzeWithAI() {
            if (!currentStreamUid) {
                log('‚ö†Ô∏è Please complete steps 1-3 first', 'warn');
                return;
            }

            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            updateStatus('Analyzing...', 'processing');
            setStep(4);

            log('ü§ñ [STEP 4] Starting AI analysis via OpenRouter...', 'info');
            log(`   ‚Üí Model: google/gemini-2.0-flash-001`, 'info');
            log(`   ‚Üí Keyframes: 8 thumbnails from Cloudflare Stream`, 'info');

            try {
                const startTime = Date.now();

                const response = await fetchWithRetry(`${WORKER_URL}/analyze/${currentStreamUid}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response || !response.ok) {
                    let details = '';
                    try {
                        if (response) {
                            const errData = await response.json();
                            details = errData.details || errData.error || await response.text();
                        }
                    } catch (e) { /* ignore parse error */ }

                    throw new Error(response ? `API Error ${response.status}: ${details}` : 'Network Error');
                }

                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                const data = await response.json();

                if (data.success && data.result) {
                    log(`   ‚Üí Analysis completed in ${elapsed}s`, 'success');
                    populateAnalysisResults(data.result, data.debug);
                    updateStatus('Complete', 'success');
                    document.getElementById('status').className = 'status ready';

                    log(`‚úÖ [STEP 4 COMPLETE] AI analysis finished!`, 'success');
                    if (data.cfUpdateStatus) {
                        log(`   ‚Üí Cloudflare Sync: ${data.cfUpdateStatus}`, data.cfUpdateStatus === 'success' ? 'success' : 'warn');
                    }
                } else {
                    const failMsg = data.error || 'Unknown error';
                    log(`‚ùå [STEP 4 FAILED] ${failMsg}`, 'error');
                    if (data.details) log(`   ‚Üí Details: ${data.details}`, 'error');
                    updateStatus('Analysis Failed', 'error');
                }

            } catch (error) {
                log(`‚ùå [STEP 4 FAILED] ${error.message}`, 'error');
                updateStatus('Analysis Failed - Retry', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'ü§ñ Trigger Analysis';
            }
        }

        async function pollForCaptions(uid) {
            let attempts = 0;
            const maxAttempts = 30; // 60 seconds (2s interval)

            const interval = setInterval(async () => {
                attempts++;
                if (attempts > maxAttempts) {
                    clearInterval(interval);
                    log('   ‚ö†Ô∏è Caption polling timed out', 'warn');
                    return;
                }

                try {
                    log(`   ... checking for captions (attempt ${attempts})`, 'default');
                    updateStatus(`Checking captions (${attempts})...`, 'processing');

                    // Check if captions are ready via the proxy endpoint
                    const res = await fetch(`${WORKER_URL}/captions/${uid}`);
                    if (res.ok) {
                        const d = await res.json();

                        // Check if we actually got content
                        if (d.vtt && d.vtt.length > 10) { // Check for minimal length > header
                            clearInterval(interval);

                            // Update VTT link status
                            const vttLinkContainer = document.getElementById('vttLinkContainer');
                            const vttProxyUrl = `${WORKER_URL}/captions/${uid}`;
                            vttLinkContainer.innerHTML = `
                                <span style="color: #10b981; margin-bottom: 10px; display: block;">‚úÖ VTT Ready</span>
                                <a href="${vttProxyUrl}" target="_blank" class="link-cyan" style="display: inline-block; margin-bottom: 5px;">
                                    üìÑ View VTT via Worker API üîó
                                </a>
                                <br>
                                <span style="color: #666; font-size: 0.75rem;">
                                    Segments: ${d.vtt.split('-->').length - 1 || 'Unknown'}
                                </span>
                            `;

                            // Update CSV content
                            const csvBox = document.getElementById('csvContent');
                            if (csvBox) csvBox.value = d.csv || '(No text in captions - video may have no speech)';

                            log(`   üìÑ Captions available! (${d.vtt.length} chars)`, 'success');
                            updateStatus('Captions Found', 'success');

                            // Optional: Re-run AI analysis if it was run without captions?
                            // For now, just show them.
                        } else {
                            // Captions might be empty or just header
                            log(`   ... captions response received but empty/short`, 'warn');
                        }
                    } else {
                        log(`   ... caption check failed: ${res.status}`, 'warn');
                    }
                } catch (e) {
                    // Ignore errors during polling
                }
            }, 2000);
        }

        function populateAnalysisResults(a, d) {
            document.getElementById('aiTitle').textContent = a.title || '-';
            document.getElementById('aiDescription').textContent = a.description || '-';
            document.getElementById('aiCategory').textContent = a.category || '-';
            document.getElementById('aiRating').textContent = a.content_rating || '-';
            document.getElementById('aiTags').innerHTML = (a.tags || [])
                .map(t => `<span class="tag-pill">${t}</span>`).join('');
            document.getElementById('aiMood').textContent = `${a.mood || '-'} / ${a.language || '-'}`;
            document.getElementById('aiConfidence').textContent = a.confidence
                ? `${(a.confidence * 100).toFixed(0)}%` : '-';

            // Populate Debug Info
            if (d) {
                document.getElementById('aiDebug').style.display = 'block';
                document.getElementById('debugSystemPrompt').textContent = d.systemPrompt || 'N/A';
                document.getElementById('debugUserPrompt').textContent = d.userPrompt || 'N/A';
                const transEl = document.getElementById('debugTranscription');
                if (transEl) {
                    transEl.textContent = d.transcription ? d.transcription.substring(0, 1000) + (d.transcription.length > 1000 ? '...' : '') : '(No transcription used)';
                }

                const shotContainer = document.getElementById('debugScreenshots');
                shotContainer.innerHTML = (d.screenshots || []).map(url =>
                    `<a href="${url}" target="_blank"><img src="${url}" style="height: 60px; border-radius: 4px; border: 1px solid #444;"></a>`
                ).join('');

                // Populate the main Keyframes panel (Panel 4) - only if we haven't already OR to update with exact frames used
                const kfMain = document.getElementById('keyframes');
                if (kfMain && d.screenshots) {
                    kfMain.innerHTML = d.screenshots.map(url =>
                        `<div class="kf-item"><img src="${url}"></div>`
                    ).join('');
                }

                log(`   ‚Üí Debug info loaded (Prompts + ${d.screenshots?.length || 0} screenshots)`, 'info');
            }
        }

        function generateKeyframes(dmId) {
            const container = document.getElementById('keyframes');
            // Use placeholder times initially (will be updated when video loads)
            const times = [0, 1, 2, 3, 4, 5, 6, 7];

            container.innerHTML = times.map((t, i) => `
                <div class="keyframe">
                    <img src="https://www.dailymotion.com/thumbnail/video/${dmId}?time=${t}" 
                         alt="Frame ${i + 1}"
                         onerror="this.parentElement.style.background='#3a3a5a'">
                    <span class="keyframe-time">${t}s</span>
                </div>
            `).join('');
            log(`   ‚Üí Generated ${times.length} initial keyframes (awaiting duration)`, 'info');
        }

        function generateKeyframesWithDuration(dmId, duration) {
            const container = document.getElementById('keyframes');
            const numFrames = 8;
            let times = [];

            if (duration <= 10) {
                // Short video: spread evenly
                for (let i = 0; i < numFrames; i++) {
                    times.push(Number((duration * i / (numFrames - 1)).toFixed(1)));
                }
            } else if (duration <= 60) {
                // Medium video: evenly distributed
                for (let i = 0; i < numFrames; i++) {
                    times.push(Math.round(duration * i / (numFrames - 1)));
                }
            } else {
                // Longer video: percentage-based
                const percentages = [0.02, 0.1, 0.2, 0.35, 0.5, 0.65, 0.8, 0.95];
                times = percentages.map(p => Math.round(duration * p));
            }

            log(`   ‚Üí Keyframe times for ${duration.toFixed(1)}s video: [${times.join(', ')}]`, 'info');

            container.innerHTML = times.map((t, i) => `
                <div class="keyframe">
                    <img src="https://www.dailymotion.com/thumbnail/video/${dmId}?time=${t}" 
                         alt="Frame ${i + 1}"
                         onerror="this.parentElement.style.background='#3a3a5a'">
                    <span class="keyframe-time">${t}s</span>
                </div>
            `).join('');
            log(`   ‚Üí Updated DailyMotion keyframes with correct timing`, 'success');
        }

        function generateStreamKeyframes(uid, duration = null) {
            const container = document.getElementById('keyframes');
            const numFrames = 8;
            let times = [];

            // Use actual video duration if available
            const videoDuration = duration || currentVideoDuration || 60;

            if (videoDuration <= 10) {
                // Very short video: spread evenly with smaller intervals
                for (let i = 0; i < numFrames; i++) {
                    times.push(Math.max(0.1, (videoDuration * i / (numFrames - 1)).toFixed(1)));
                }
            } else if (videoDuration <= 60) {
                // Short video (under 1 min): evenly distributed
                for (let i = 0; i < numFrames; i++) {
                    times.push(Math.round(videoDuration * i / (numFrames - 1)));
                }
            } else {
                // Longer video: use percentage-based distribution
                const percentages = [0.02, 0.1, 0.2, 0.35, 0.5, 0.65, 0.8, 0.95];
                times = percentages.map(p => Math.round(videoDuration * p));
            }

            log(`   ‚Üí Keyframe times calculated for ${videoDuration.toFixed(1)}s video: [${times.join(', ')}]`, 'info');

            container.innerHTML = times.map((t, i) => `
                <div class="keyframe">
                    <img src="https://videodelivery.net/${uid}/thumbnails/thumbnail.jpg?time=${t}s&width=640" 
                         alt="Frame ${i + 1}"
                         onerror="this.style.opacity='0.3'">
                    <span class="keyframe-time">${t}s</span>
                </div>
            `).join('');
            log(`   ‚Üí Updated to Cloudflare Stream keyframes (${times.length} frames)`, 'info');
        }

        function displaySignedThumbnails(signedUrls, duration) {
            const container = document.getElementById('keyframes');
            const times = [];
            const numFrames = signedUrls.length;

            // Calculate times based on duration for labels
            if (duration <= 10) {
                for (let i = 0; i < numFrames; i++) {
                    times.push(Number((duration * i / (numFrames - 1)).toFixed(1)));
                }
            } else if (duration <= 60) {
                for (let i = 0; i < numFrames; i++) {
                    times.push(Math.round(duration * i / (numFrames - 1)));
                }
            } else {
                const percentages = [0.02, 0.1, 0.2, 0.35, 0.5, 0.65, 0.8, 0.95];
                for (let i = 0; i < numFrames; i++) {
                    times.push(Math.round(duration * (percentages[i] || i / numFrames)));
                }
            }

            container.innerHTML = signedUrls.map((url, i) => `
                <div class="keyframe">
                    <img src="${url}" 
                         alt="Frame ${i + 1}"
                         onerror="this.style.opacity='0.3'">
                    <span class="keyframe-time">${times[i]}s</span>
                </div>
            `).join('');
            log(`   ‚Üí Displayed ${signedUrls.length} signed Stream keyframes`, 'success');
        }

        async function validateAndShowVideo(data, uid) {
            const hlsUrl = data.signedPlaybackUrl;
            log(`   ‚Üí Validating HLS link: ${hlsUrl}`, 'info');

            try {
                const response = await fetch(hlsUrl, { method: 'HEAD' });
                if (response.ok) {
                    log(`   ‚úÖ Link Valid (200 OK)`, 'success');
                    showProcessedVideo(data, uid, true);
                } else {
                    log(`   ‚ùå Link Invalid (${response.status} ${response.statusText})`, 'error');
                    console.error('Invalid Link Response:', response);
                    // Show anyway so user can debug raw link
                    showProcessedVideo(data, uid, false);
                }
            } catch (e) {
                log(`   ‚ö†Ô∏è Link validation failed (network error?): ${e.message}`, 'warn');
                showProcessedVideo(data, uid, false);
            }
        }

        function showProcessedVideo(data, uid, isValid) {
            const hlsUrl = data.signedPlaybackUrl;
            const dashUrl = data.signedDashUrl;
            const downloadUrl = data.signedDownloadUrl;

            // Prefer Iframe URL if available, else standard fallback
            const iframeUrl = data.iframeUrl;

            const processedSection = document.getElementById('processedVideoSection');
            if (!processedSection) {
                log('‚ùå Could not find processedVideoSection element', 'error');
                return;
            }

            processedSection.style.display = 'block';

            // Build the player HTML (Iframe or Video)
            let playerHtml = '';
            if (iframeUrl) {
                // Construct Iframe with poster if available
                let src = iframeUrl + '?preload=true&autoplay=false';
                if (data.signedThumbnails && data.signedThumbnails.length > 0) {
                    src += `&poster=${encodeURIComponent(data.signedThumbnails[0])}`;
                }

                playerHtml = `
                <div class="video-fit-container">
                  <iframe
                    src="${src}"
                    loading="lazy"
                    allow="accelerometer; gyroscope; autoplay; encrypted-media; picture-in-picture;"
                    allowfullscreen="true"
                    id="processedIframe"
                  ></iframe>
                </div>`;
            } else {
                playerHtml = `
                <div class="video-fit-container">
                    <video id="processedPlayer" controls playsinline></video>
                </div>`;
            }

            processedSection.innerHTML = `
                <h4 style="color: #a855f7; margin-bottom: 10px;">
                    üé¨ Processed Video (Cloudflare Stream) 
                    ${isValid ? '<span style="color: #10b981; font-size: 0.8em">‚úÖ Validated</span>' : '<span style="color: #ef4444; font-size: 0.8em">‚ö†Ô∏è Check Links</span>'}
                </h4>
                ${playerHtml}
                <div class="source-urls">
                    <div class="mb-5"><strong>Stream UID:</strong> ${uid}</div>
                    <div class="mb-5"><strong>Iframe URL:</strong> <a href="${iframeUrl}" target="_blank" class="link-cyan">Open Fullscreen üîó</a></div>
                    <div class="mb-5"><strong>HLS URL:</strong> <a href="${hlsUrl}" target="_blank" class="link-cyan">Active Link üîó</a></div>
                    ${dashUrl ? `<div class="mb-5"><strong>DASH URL:</strong> <a href="${dashUrl}" target="_blank" class="link-cyan">Active Link üîó</a></div>` : ''}
                    ${downloadUrl ? `<div class="mb-5"><strong>Download (MP4):</strong> <a href="${downloadUrl}" target="_blank" class="link-cyan">Download üíæ</a></div>` : ''}
                </div>
            `;

            // If we fell back to <video> tag (no iframeUrl), ensure HLS loads
            if (!iframeUrl) {
                // Load HLS video
                const video = document.getElementById('processedPlayer');
                // Check if browser supports HLS natively (Safari)
                if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = hlsUrl;
                } else {
                    // Use HLS.js for other browsers
                    if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                        const hls = new Hls();
                        hls.loadSource(hlsUrl);
                        hls.attachMedia(video);
                    } else {
                        video.src = hlsUrl; // Try direct anyway
                    }
                }
            }
        }
    </script>
</body>

</html>